# Test Requirements: Nemotron CPU Fallback

## Automated Tests

| AC | Description | Test Type | Test Location | Notes |
|----|-------------|-----------|---------------|-------|
| AC1.1 | `stt/moonshine.rs` deleted, `tokenizers` crate removed, project builds | Integration | `tests/build_sanity.rs` or CI script (`cargo build`) | Verified by successful `cargo build`. No dedicated test file needed; CI pipeline covers this. Could add a compile-fail test asserting `use crate::stt::moonshine` does not resolve. |
| AC1.2 | All Moonshine model management functions removed from `models/mod.rs` | Unit | `src/models/mod.rs` (existing test module) | Existing Nemotron model tests remain and pass. Moonshine-specific tests (e.g., `test_moonshine_model_dir_contains_models_dir`, `test_moonshine_model_files_have_correct_names`, `test_moonshine_models_present_nonexistent_returns_false`, `test_moonshine_models_present_when_files_exist`) are deleted as part of the implementation. Verified by `cargo test` passing with reduced test count. |
| AC1.3 | Case-insensitive grep for `moonshine` returns zero results outside design/plan docs | Integration | CI script or `tests/no_moonshine_refs.rs` | A shell-based test: `grep -ri moonshine --include='*.rs' --include='*.toml' --include='*.md' . \| grep -v design-plans \| grep -v implementation-plans \| grep -v test-plans \| grep -v '.git'` must produce empty output. Best implemented as a CI lint step rather than a Rust test. |
| AC2.1 | Config with `engine = "moonshine"` logs warning and defaults to Nemotron | Unit | `src/config.rs` (test module) | Add test: parse TOML containing `engine = "moonshine"`, assert `Config::load()` returns `Engine::Nemotron` (via serde unknown-variant fallback to defaults). The implementation plan notes this falls through existing error handling in `Config::load()` (lines 183-196) which returns defaults on parse error. Update `config_partial_toml_fills_defaults` or add a new `config_unknown_engine_defaults_to_nemotron` test. |
| AC2.2 | CLI `--engine nemotron` and `--engine parakeet` still work | Unit | `src/main.rs` or `tests/cli.rs` | Test the CLI match block: both `"nemotron"` and `"parakeet"` map to `Engine::Nemotron`. If CLI parsing is extracted into a function, unit-test it directly. Otherwise, integration test via `cargo run -- --engine nemotron --help` or similar. |
| AC2.3 | CLI `--engine moonshine` prints helpful error and exits | Integration | `tests/cli.rs` | Run the binary with `--engine moonshine`, assert exit code is non-zero and stderr contains "Unknown engine" and "Valid engines: nemotron, parakeet". Implementation uses `std::process::exit(1)` so this must be a process-level test. |
| AC3.1 | When CUDA unavailable, Nemotron starts on CPU and logs info message | Integration | `tests/cuda_fallback.rs` | Difficult to unit test because `cuda_available()` queries real hardware. Two approaches: (1) run on a CI node without CUDA and assert stderr contains "CUDA not available, Nemotron will use CPU", or (2) extract the logging branch into a testable function that takes a bool parameter. The implementation plan hardcodes `stt::cuda_available()` inline in main.rs, so option 1 is more aligned with the plan. |
| AC3.2 | When CUDA available, Nemotron starts with GPU (no behavioral change) | Integration | `tests/cuda_fallback.rs` | Same approach as AC3.1 but on a CUDA-equipped CI node. Assert stderr contains "CUDA available, Nemotron will use GPU acceleration". |
| AC4.1 | Engine submenu hidden when only one engine variant exists | Unit | `src/tray/mod.rs` (test module) | Assert that the `menu()` method output does not contain a `MenuItem` with label "STT Engine". The existing tray test infrastructure constructs a `TrayState` and calls `menu()`. Add assertion that no submenu label matches "STT Engine". The `build_engine_submenu` function is preserved with `#[allow(dead_code)]` and can be separately tested for future-proofing. |

## Human Verification

| AC | Description | Justification | Verification Approach |
|----|-------------|---------------|----------------------|
| AC3.1 | Nemotron actually produces correct transcriptions when running on CPU | Automated tests can verify startup and logging but cannot assess STT output quality on CPU. The parakeet-rs library handles execution provider selection internally, and verifying inference correctness requires feeding real audio and evaluating transcript quality. | Run the application on a machine without CUDA. Play a known audio clip (e.g., a TTS-generated sentence). Verify the overlay displays a reasonable transcription. Latency may be higher on CPU but output should be intelligible. |
| AC3.2 | Nemotron GPU path has no behavioral regression | Verifying that GPU inference is actually being used (not silently falling back to CPU) and produces correct output at expected latency requires hardware and real audio. | Run the application on a CUDA-equipped machine. Confirm via `nvidia-smi` that the ort process is using GPU memory. Play a known audio clip and verify transcription accuracy and latency are comparable to pre-change behavior. |
| AC4.1 | Tray menu visually renders without engine submenu | While the menu data structure can be tested in unit tests, the actual rendering via ksni and the D-Bus StatusNotifierItem protocol depends on the desktop environment's tray implementation. | Launch the application, right-click the tray icon, and confirm no "STT Engine" submenu appears. Verify other menu items (Overlay, Quit, etc.) still render correctly. |
| AC1.3 | No stale Moonshine references in user-facing strings or tooltips | Grep catches source code references but may miss dynamically constructed strings, notification text, or D-Bus-exposed metadata. | Launch the application with and without CUDA. Check tray tooltip, tray title, any desktop notifications, and config file comments for residual "moonshine" or "Moonshine" text. |
